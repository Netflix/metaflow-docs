# FlowSpec - Constructing flows

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! Instead, edit the notebook w/the location & name as this file. -->

Metaflow [flows are defined](/metaflow/basics) by inhering from the `FlowSpec` class:
```python
from metaflow import FlowSpec, step

class MyFlow(FlowSpec):

    @step
    def start(self):
        self.next(self.end)
       
    @step
    def end(self):
        pass

if __name__ == '__main__':
    MyFlow()
```

This class has no other uses. It can't be instantiated directly.

`FlowSpec` exposes a few methods and attributes that you can use to construct a flow, which are listed below. You can add more functionality in your flows through [step-level decorators](step-decorators) and [flow-level decorators](flow-decorators).

You can parametrize flows through the [`Parameter`](#parameters) object that are defined as class variables inside a flow. You can also include files as parameters through the [`IncludeFile`](#includefile) object.

To query and manipulate the currently executing run inside your flow, see the [`current`](current) object. To access results produced by a flow, see the [Client API](client).

## Defining a workflow

Annotate methods that are a part of your Metaflow workflow with [the `@step` decorator](/api/step-decorators/step). Use `FlowSpec.next` to define transitions between steps:


<DocSection type="method" name="FlowSpec.next" module="metaflow" show_import="False" heading_level="4" link="https://github.com/Netflix/metaflow/tree/master/metaflow/flowspec.py#L556">
<SigArgSection>
<SigArg name="*dsts, foreach=None" />
</SigArgSection>
<Description summary="Indicates the next step to execute after this step has completed." extended_summary="This statement should appear as the last statement of each step, except\nthe end step.\n\nThere are several valid formats to specify the next step:\n\n- Straight-line connection: `self.next(self.next_step)` where `next_step` is a method in\n  the current class decorated with the `@step` decorator.\n\n- Static fan-out connection: `self.next(self.step1, self.step2, ...)` where `stepX` are\n  methods in the current class decorated with the `@step` decorator.\n\n- Foreach branch:\n  ```\n  self.next(self.foreach_step, foreach='foreach_iterator')\n  ```\n  In this situation, `foreach_step` is a method in the current class decorated with the\n  `@step` decorator and `foreach_iterator` is a variable name in the current class that\n  evaluates to an iterator. A task will be launched for each value in the iterator and\n  each task will execute the code specified by the step `foreach_step`." />
<ParamSection name="Parameters">
	<Parameter name="dsts" type="Callable[..., None]" desc="One or more methods annotated with `@step`." />
</ParamSection>
<ParamSection name="Raises">
	<Parameter type="InvalidNextException" desc="Raised if the format of the arguments does not match one of the ones given above." />
</ParamSection>
</DocSection>


## Working with foreaches

Use the operations below, `FlowSpec.input`, `FlowSpec.index`, and `FlowSpec.foreach_stack` to query the status of the currently executing foreach branch. Use `FlowSpec.merge_artifacts()` to handle incoming artifacts in a join step.


<DocSection type="property" name="FlowSpec.input" module="metaflow.flowspec" show_import="False" heading_level="4" link="https://github.com/Netflix/metaflow/tree/master/">

<Description summary="The value of the foreach artifact in this foreach branch.\n\nIn a foreach step, multiple instances of this step (tasks) will be executed,\none for each element in the foreach. This property returns the element passed\nto the current task. If this is not a foreach step, this returns None.\n\nIf you need to know the values of the parent tasks in a nested foreach, use\n`FlowSpec.foreach_stack`.\n" />
<ParamSection name="Returns">
<Parameter type="object, optional" desc="Input passed to the foreach task." />
</ParamSection>
</DocSection>



<DocSection type="property" name="FlowSpec.index" module="metaflow.flowspec" show_import="False" heading_level="4" link="https://github.com/Netflix/metaflow/tree/master/">

<Description summary="The index of this foreach branch.\n\nIn a foreach step, multiple instances of this step (tasks) will be executed,\none for each element in the foreach. This property returns the zero based index\nof the current task. If this is not a foreach step, this returns None.\n\nIf you need to know the indices of the parent tasks in a nested foreach, use\n`FlowSpec.foreach_stack`.\n" />
<ParamSection name="Returns">
<Parameter type="int, optional" desc="Index of the task in a foreach step." />
</ParamSection>
</DocSection>



<DocSection type="method" name="FlowSpec.foreach_stack" module="metaflow" show_import="False" heading_level="4" link="https://github.com/Netflix/metaflow/tree/master/metaflow/flowspec.py#L301">
<SigArgSection>
<SigArg name="self" />
</SigArgSection>
<Description summary="Returns the current stack of foreach indexes and values for the current step." extended_summary="Use this information to understand what data is being processed in the current\nforeach branch. For example, considering the following code:\n```\n@step\ndef root(self):\n    self.split_1 = ['a', 'b', 'c']\n    self.next(self.nest_1, foreach='split_1')\n\n@step\ndef nest_1(self):\n    self.split_2 = ['d', 'e', 'f', 'g']\n    self.next(self.nest_2, foreach='split_2'):\n\n@step\ndef nest_2(self):\n    foo = self.foreach_stack()\n```\n\n`foo` will take the following values in the various tasks for nest_2:\n```\n    [(0, 3, 'a'), (0, 4, 'd')]\n    [(0, 3, 'a'), (1, 4, 'e')]\n    ...\n    [(0, 3, 'a'), (3, 4, 'g')]\n    [(1, 3, 'b'), (0, 4, 'd')]\n    ...\n```\nwhere each tuple corresponds to:\n\n- The index of the task for that level of the loop.\n- The number of splits for that level of the loop.\n- The value for that level of the loop.\n\nNote that the last tuple returned in a task corresponds to:\n\n- 1st element: value returned by `self.index`.\n- 3rd element: value returned by `self.input`." />
<ParamSection name="Returns">
	<Parameter type="List[Tuple[int, int, Any]]" desc="An array describing the current stack of foreach steps." />
</ParamSection>
</DocSection>



<DocSection type="method" name="FlowSpec.merge_artifacts" module="metaflow" show_import="False" heading_level="4" link="https://github.com/Netflix/metaflow/tree/master/metaflow/flowspec.py#L385">
<SigArgSection>
<SigArg name="self" /><SigArg name="inputs" type="Inputs" /><SigArg name="exclude" type="Optional" default="None" /><SigArg name="include" type="Optional" default="None" />
</SigArgSection>
<Description summary="Helper function for merging artifacts in a join step." extended_summary="This function takes all the artifacts coming from the branches of a\njoin point and assigns them to self in the calling step. Only artifacts\nnot set in the current step are considered. If, for a given artifact, different\nvalues are present on the incoming edges, an error will be thrown and the artifacts\nthat conflict will be reported.\n\nAs a few examples, in the simple graph: A splitting into B and C and joining in D:\n```\nA:\n  self.x = 5\n  self.y = 6\nB:\n  self.b_var = 1\n  self.x = from_b\nC:\n  self.x = from_c\n\nD:\n  merge_artifacts(inputs)\n```\nIn D, the following artifacts are set:\n  - `y` (value: 6), `b_var` (value: 1)\n  - if `from_b` and `from_c` are the same, `x` will be accessible and have value `from_b`\n  - if `from_b` and `from_c` are different, an error will be thrown. To prevent this error,\n    you need to manually set `self.x` in D to a merged value (for example the max) prior to\n    calling `merge_artifacts`." />
<ParamSection name="Parameters">
	<Parameter name="inputs" type="Inputs" desc="Incoming steps to the join point." />
	<Parameter name="exclude" type="List[str], optional, default None" desc="If specified, do not consider merging artifacts with a name in `exclude`.\nCannot specify if `include` is also specified." />
	<Parameter name="include" type="List[str], optional, default None" desc="If specified, only merge artifacts specified. Cannot specify if `exclude` is\nalso specified." />
</ParamSection>
<ParamSection name="Raises">
	<Parameter type="MetaflowException" desc="This exception is thrown if this is not called in a join step." />
	<Parameter type="UnhandledInMergeArtifactsException" desc="This exception is thrown in case of unresolved conflicts." />
	<Parameter type="MissingInMergeArtifactsException" desc="This exception is thrown in case an artifact specified in `include` cannot\nbe found." />
</ParamSection>
</DocSection>


## Parameters

The `Parameter` class is used to define parameters for a flow.

The `Parameter` objects must be defined as class variables inside a flow. The parameter values are available as read-only artifacts in all steps of the flow. For instructions, see [How to define parameters for flows](/metaflow/basics#how-to-define-parameters-for-flows).


<DocSection type="class" name="Parameter" module="metaflow" show_import="False" heading_level="3" link="https://github.com/Netflix/metaflow/tree/master/metaflow/parameters.py#L249">
<SigArgSection>
<SigArg name="name" type="str" /><SigArg name="default" type="Union" default="None" /><SigArg name="type" type="Union" default="None" /><SigArg name="help" type="Optional" default="None" /><SigArg name="required" type="bool" default="False" /><SigArg name="show_default" type="bool" default="True" /><SigArg name="**kwargs: Dict[str, Any]" type="Dict" />
</SigArgSection>
<Description summary="Defines a parameter for a flow." extended_summary="Parameters must be instantiated as class variables in flow classes, e.g.\n```\nclass MyFlow(FlowSpec):\n    param = Parameter('myparam')\n```\nin this case, the parameter is specified on the command line as\n```\npython myflow.py run --myparam=5\n```\nand its value is accessible through a read-only artifact like this:\n```\nprint(self.param == 5)\n```\nNote that the user-visible parameter name, `myparam` above, can be\ndifferent from the artifact name, `param` above.\n\nThe parameter value is converted to a Python type based on the `type`\nargument or to match the type of `default`, if it is set." />
<ParamSection name="Parameters">
	<Parameter name="name" type="str" desc="User-visible parameter name." />
	<Parameter name="default" type="str or float or int or bool or `JSONType` or a function." desc="Default value for the parameter. Use a special `JSONType` class to\nindicate that the value must be a valid JSON object. A function\nimplies that the parameter corresponds to a *deploy-time parameter*.\nThe type of the default value is used as the parameter `type`." />
	<Parameter name="type" type="Type, default None" desc="If `default` is not specified, define the parameter type. Specify\none of `str`, `float`, `int`, `bool`, or `JSONType`. If None, defaults\nto the type of `default` or `str` if none specified." />
	<Parameter name="help" type="str, optional" desc="Help text to show in `run --help`." />
	<Parameter name="required" type="bool, default False" desc="Require that the user specified a value for the parameter.\n`required=True` implies that the `default` is not used." />
	<Parameter name="show_default" type="bool, default True" desc="If True, show the default value in the help text." />
</ParamSection>
</DocSection>


### Deploy-time parameters

It is possible to define the `default` value programmatically before a run or a deployment is executed through a user-defined function. For more information, see [documentation for Deploy Time Parameters](/production/scheduling-metaflow-flows/scheduling-with-aws-step-functions#deploy-time-parameters).

For instance, the following deploy-time parameter, `time`, uses the current time as its default value:
```python
def time_now(context):
    return int(time.time())

class MyFlow(FlowSpec):
    myparam = Parameter("time", type=int, default=time_now)
```
Note that if the function returns a non-string value, you must specify the parameter `type` when using deploy-time parameters, as the type of `default` can't be inferred automatically.

The function called gets a parameter `context` that contains attributes about the current parameter which you can use to customize the value returned:


<DocSection type="class" name="ParameterContext" module="metaflow" show_import="False" heading_level="3" link="https://github.com/Netflix/metaflow/tree/master/">
<SigArgSection>

</SigArgSection>
<Description summary="Information about the parameter being evaluated." />
<ParamSection name="Attributes">
	<Parameter name="flow_name" type="str" desc="Flow name" />
	<Parameter name="user_name" type="str" desc="User name" />
	<Parameter name="parameter_name" type="str" desc="Parameter name" />
</ParamSection>
</DocSection>


## IncludeFile

The `IncludeFile` object is a special `Parameter` that reads its value from a local file. For an example, see [Data in Local Files](/scaling/data#data-in-local-files).


<DocSection type="class" name="IncludeFile" module="metaflow" show_import="False" heading_level="3" link="https://github.com/Netflix/metaflow/tree/master/metaflow/includefile.py#L231">
<SigArgSection>
<SigArg name="name, **kwargs" />
</SigArgSection>
<Description summary="Includes a local file as a parameter for the flow." extended_summary="`IncludeFile` behaves like `Parameter` except that it reads its value from a file instead of\nthe command line. The user provides a path to a file on the command line. The file contents\nare saved as a read-only artifact which is available in all steps of the flow." />
<ParamSection name="Parameters">
	<Parameter name="name" type="str" desc="User-visible parameter name." />
	<Parameter name="default" type="Union[str, Callable[ParameterContext, str]]" desc="Default path to a local file. A function\nimplies that the parameter corresponds to a *deploy-time parameter*." />
	<Parameter name="is_text" type="bool, default True" desc="Convert the file contents to a string using the provided `encoding`.\nIf False, the artifact is stored in `bytes`." />
	<Parameter name="encoding" type="str, optional, default 'utf-8'" desc="Use this encoding to decode the file contexts if `is_text=True`." />
	<Parameter name="required" type="bool, default False" desc="Require that the user specified a value for the parameter.\n`required=True` implies that the `default` is not used." />
	<Parameter name="help" type="str, optional" desc="Help text to show in `run --help`." />
	<Parameter name="show_default" type="bool, default True" desc="If True, show the default value in the help text." />
</ParamSection>
</DocSection>

