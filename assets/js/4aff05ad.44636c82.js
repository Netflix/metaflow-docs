"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4594],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),s=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),d=a,k=u["".concat(l,".").concat(d)]||u[d]||h[d]||i;return n?o.createElement(k,r(r({ref:t},p),{},{components:n})):o.createElement(k,r({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,r[1]=c;for(var s=2;s<i;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2445:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const i={},r="Selecting a Checkpoint to Use",c={unversionedId:"scaling/checkpoint/selecting-checkpoints",id:"scaling/checkpoint/selecting-checkpoints",title:"Selecting a Checkpoint to Use",description:"By default, @checkpoint is scoped to a single task, allowing you to recover from a previous checkpoint using @retry.",source:"@site/docs/scaling/checkpoint/selecting-checkpoints.md",sourceDirName:"scaling/checkpoint",slug:"/scaling/checkpoint/selecting-checkpoints",permalink:"/scaling/checkpoint/selecting-checkpoints",draft:!1,editUrl:"https://github.dev/Netflix/metaflow-docs/blob/master/docs/scaling/checkpoint/selecting-checkpoints.md",tags:[],version:"current",frontMatter:{},sidebar:"python",previous:{title:"Checkpoints in ML/AI libraries",permalink:"/scaling/checkpoint/checkpoint-ml-libraries"},next:{title:"Loading and Storing Data",permalink:"/scaling/data"}},l={},s=[{value:"<code>load_policy=&#39;fresh&#39;</code> - retry tasks without losing progress",id:"load_policyfresh---retry-tasks-without-losing-progress",level:3},{value:"<code>load_policy=&#39;eager&#39;</code> - make progress incrementally across runs",id:"load_policyeager---make-progress-incrementally-across-runs",level:3},{value:"<code>load_policy=None</code> - choose your own policy",id:"load_policynone---choose-your-own-policy",level:3},{value:"Listing checkpoints",id:"listing-checkpoints",level:2},{value:"Loading checkpoints outside flows",id:"loading-checkpoints-outside-flows",level:2}],p={toc:s};function h(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"selecting-a-checkpoint-to-use"},"Selecting a Checkpoint to Use"),(0,a.kt)("p",null,"By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint")," is scoped to a single task, allowing you to recover from a previous checkpoint using ",(0,a.kt)("inlineCode",{parentName:"p"},"@retry"),".\nThis behavior is desirable when implementing a step that must preserve progress in case of unexpected interruptions or\nretries. When initiating a new run, any existing checkpoints are disregarded to avoid accidentally loading stale or\nincorrect checkpoints."),(0,a.kt)("p",null,"At times, it is useful to reuse checkpoints across different runs or even leverage checkpoints created by another\nworkflow, such as one trained by a colleague. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint")," decorator enables this functionality by allowing you to\nconfigure checkpoint loading behavior using the ",(0,a.kt)("inlineCode",{parentName:"p"},"load_policy")," argument."),(0,a.kt)("p",null,"The decorator supports three distinct load policies, as depicted below:"),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(2518).Z,width:"1500",height:"843"})),(0,a.kt)("p",null,"Let\u2019s cover the policies from left to right:"),(0,a.kt)("h3",{id:"load_policyfresh---retry-tasks-without-losing-progress"},(0,a.kt)("inlineCode",{parentName:"h3"},"load_policy='fresh'")," - retry tasks without losing progress"),(0,a.kt)("p",null,"This is the default policy. Checkpoints are scoped to a task: The latest available task-specific checkpoint is loaded\nautomatically upon ",(0,a.kt)("inlineCode",{parentName:"p"},"@retry"),". Checkpoints are not loaded across runs. This behavior is often desirable in deployed\nflows, which should be able to recover from unexpected failures while remaining isolated from any other concurrent\nruns."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Checkpoints are scoped to a task based on the flow name, step name, and foreach index. This ensures that you can\nuse ",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint")," in foreach tasks, e.g. when running a hyperparameter search, training multiple models in parallel.\nEach model gets a dedicated set of checkpoints without interference from concurrent tasks.")),(0,a.kt)("h3",{id:"load_policyeager---make-progress-incrementally-across-runs"},(0,a.kt)("inlineCode",{parentName:"h3"},"load_policy='eager'")," - make progress incrementally across runs"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"eager")," policy is well suited for iterative development: It allows you to interrupt a run and resume it later in\nanother run, preserving progress made within a task. For instance, you can train a model for a few epochs, interrupt\ntraining, change code, and use the resume command to resume training from the latest checkpoint."),(0,a.kt)("p",null,"Test this by changing ",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint(load_policy=\u2019eager\u2019)")," in ",(0,a.kt)("a",{parentName:"p",href:"/scaling/checkpoint/introduction#using-checkpoint"},"our earlier ",(0,a.kt)("inlineCode",{parentName:"a"},"CheckpointCounterFlow"),"\nexample"),". Run the flow, interrupt a ",(0,a.kt)("inlineCode",{parentName:"p"},"flaky_count")," step after a\nwhile, and try ",(0,a.kt)("inlineCode",{parentName:"p"},"python checkpoint_counter.py resume flaky_count")," You\u2019ll notice that ",(0,a.kt)("inlineCode",{parentName:"p"},"flaky_count")," will load an\nexisting checkpoint. If the step has run to completion earlier, the latest checkpoint allows you to skip processing\naltogether. If you modify the code and want to ignore past stale checkpoints, simply change the checkpoint back to\n",(0,a.kt)("inlineCode",{parentName:"p"},"@checkpoint(load_policy=\u2019fresh\u2019)"),". "),(0,a.kt)("p",null,"Note that eager mode operates within ",(0,a.kt)("a",{parentName:"p",href:"/scaling/tagging"},"the current namespace"),". That is, it will only consider\ncheckpoints created by you, not those created by your colleagues. This is deliberate as we want to ensure that multiple\npeople can work concurrently with deterministic results. If you want to load checkpoints across namespaces, the next\nload policy will come in handy."),(0,a.kt)("h3",{id:"load_policynone---choose-your-own-policy"},(0,a.kt)("inlineCode",{parentName:"h3"},"load_policy=None")," - choose your own policy"),(0,a.kt)("p",null,"If the fresh and eager policies don\u2019t work for your needs, you can take control of what checkpoints are loaded and when\nby setting ",(0,a.kt)("inlineCode",{parentName:"p"},"load_policy=None"),". In this case, no checkpoints are loaded automatically. Instead, you are expected to\nimplement custom logic that chooses what checkpoint to load."),(0,a.kt)("p",null,"It is a useful pattern to store a reference to the latest checkpoint - returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"save()")," - in an artifact which\nallows you to find specific checkpoints using ",(0,a.kt)("a",{parentName:"p",href:"/metaflow/client"},"the Client API"),". This makes it easy to implement\nrobust custom policies for loading checkpoints produced by specific flows and deployments, while staying organized with\nthe lineage of checkpoints."),(0,a.kt)("p",null,"This example illustrates the idea, loading a checkpoint produced by the above ",(0,a.kt)("inlineCode",{parentName:"p"},"CheckpointCounterFlow"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import os\n\nfrom metaflow import FlowSpec, current, step, retry, checkpoint, Flow, namespace\n\nclass CounterPolicyFlow(FlowSpec):\n\n    @checkpoint(load_policy=None)\n    @step\n    def start(self):\n        namespace(None)\n        run = Flow('CheckpointCounterFlow').latest_successful_run\n        print(f\"Accessing checkpoints from run {run.pathspec}\")\n        cp = run['flaky_count'].task['latest_checkpoint'].data\n        current.checkpoint.load(cp)\n        with open(os.path.join(current.checkpoint.directory, 'counter')) as f:\n            self.counter = int(f.read())\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print(\"Loaded counter\", self.counter)\n\n\nif __name__ == \"__main__\":\n    CounterPolicyFlow()\n")),(0,a.kt)("p",null,"This flow refers to the latest successful execution of ",(0,a.kt)("inlineCode",{parentName:"p"},"CheckpointCounterFlow")," ",(0,a.kt)("a",{parentName:"p",href:"/scaling/tagging#global-namespace"},"across all namespaces, thanks to\n",(0,a.kt)("inlineCode",{parentName:"a"},"namespace(None)")),", allowing it to pick the latest checkpoint produced by any\nproduction deployment or a colleague who has run the flow. It finds a reference to the latest checkpoint through the\n",(0,a.kt)("inlineCode",{parentName:"p"},"latest_checkpoint")," artifact and loads it by passing it as an argument to ",(0,a.kt)("inlineCode",{parentName:"p"},"current.checkpoint.load"),"."),(0,a.kt)("h2",{id:"listing-checkpoints"},"Listing checkpoints"),(0,a.kt)("p",null,"Imagine the following scenario: You have deployed a long-running training run ",(0,a.kt)("a",{parentName:"p",href:"/production/introduction"},"in\nproduction")," which takes days to complete. While training is making progress, you want to load a\ncheckpoint produced by it into another flow, e.g. to test the model-in-progress. As the training task hasn't finished,\nwe can\u2019t access the checkpoint through an artifact as we did in the snippet above, since artifacts are only persisted\nupon task completion,"),(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"current.checkpoint.list(task=Task)")," to list checkpoints associated with a task, even a currently running\none. To see this in action, you can alter ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterPolicyFlow")," to use list to find the latest checkpoint from the\n",(0,a.kt)("inlineCode",{parentName:"p"},"flaky_count")," step, which may or may not have completed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"namespace(None)\nrun = Flow('CheckpointCounterFlow').latest_run\ncp = current.checkpoint.list(task=run['flaky_count'].task)[0]\ncurrent.checkpoint.load(cp)\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"list")," call returns all checkpoints produced by the task, so you are not limited to selecting the latest one. You\ncan even compare progress across checkpoints by loading each one of them separately."),(0,a.kt)("h2",{id:"loading-checkpoints-outside-flows"},"Loading checkpoints outside flows"),(0,a.kt)("p",null,"You can load checkpoints outside flows, e.g. in a notebook. You can import a ",(0,a.kt)("inlineCode",{parentName:"p"},"Checkpoint")," object and use it as a context manager, similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"current.checkpoint"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import os\nfrom metaflow import Checkpoint, Flow\n\nwith Checkpoint() as cp:\n    run = Flow('CheckpointCounterFlow').latest_run\n    latest = cp.list(task=run['flaky_count'].task)[0]\n    cp.load(latest)\n    with open(os.path.join(cp.directory, 'counter')) as f:\n        print(f.read())\n")),(0,a.kt)("p",null,"To load a checkpoint, simply pass a reference to an existing checkpoint to ",(0,a.kt)("inlineCode",{parentName:"p"},"Checkpoint.load"),"."),(0,a.kt)("p",null,"When used as a context manager, ",(0,a.kt)("inlineCode",{parentName:"p"},"Checkpoint")," will take care of creating and cleaning up a temporary directory for loading checkpoint data automatically."))}h.isMDXComponent=!0},2518:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/checkpoint_load_policy-014f4db894d7e3b40e9dba89c10ed19f.png"}}]);