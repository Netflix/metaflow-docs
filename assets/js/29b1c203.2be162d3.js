"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1250],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=m(e,["components","mdxType","originalType","parentName"]),d=l(n),c=a,y=d["".concat(s,".").concat(c)]||d[c]||p[c]||o;return n?r.createElement(y,i(i({ref:t},u),{},{components:n})):r.createElement(y,i({ref:t},u))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var m={};for(var s in t)hasOwnProperty.call(t,s)&&(m[s]=t[s]);m.originalType=e,m.mdxType="string"==typeof e?e:a,i[1]=m;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3020:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>k,frontMatter:()=>o,metadata:()=>m,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={},i="Runner - Running flows programmatically",m={unversionedId:"api/runner",id:"api/runner",title:"Runner - Running flows programmatically",description:"The Runner class and its notebook-focused counterpart NBRunner allow you to start runs and resume them programmatically. For an overview, see Managing Flows in Notebooks and Scripts.",source:"@site/docs/api/runner.md",sourceDirName:"api",slug:"/api/runner",permalink:"/api/runner",draft:!1,editUrl:"https://github.dev/Netflix/metaflow-docs/blob/master/docs/api/runner.md",tags:[],version:"current",frontMatter:{},sidebar:"python",previous:{title:"Current - Operating a run",permalink:"/api/current"},next:{title:"Deployer - Deploying flows programmatically",permalink:"/api/deployer"}},s={},l=[{value:"Runner",id:"runner",level:2},{value:"Blocking API",id:"blocking-api",level:3},{value:"Non-Blocking API",id:"non-blocking-api",level:3},{value:"NBRunner",id:"nbrunner",level:2},{value:"Blocking API",id:"blocking-api-1",level:3},{value:"Non-Blocking API",id:"non-blocking-api-1",level:3},{value:"ExecutingRun",id:"executingrun",level:2},{value:"Non-Blocking API",id:"non-blocking-api-2",level:3}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},p=u("DocSection"),d=u("SigArgSection"),c=u("SigArg"),y=u("Description"),h=u("ParamSection"),f=u("Parameter"),g={toc:l};function k(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"runner---running-flows-programmatically"},"Runner - Running flows programmatically"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Runner")," class and its notebook-focused counterpart ",(0,a.kt)("inlineCode",{parentName:"p"},"NBRunner")," allow you to start runs and resume them programmatically. For an overview, see ",(0,a.kt)("a",{parentName:"p",href:"/metaflow/managing-flows/introduction"},"Managing Flows in Notebooks and Scripts"),"."),(0,a.kt)("h2",{id:"runner"},"Runner"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Runner")," object is typically used as a context manager:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"with Runner(...) as runner:\n    ...\n")),(0,a.kt)("p",null,"note that ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecutingRun")," returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"async_run")," works as a context manager as well, so you can do"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"with Runner(...).run() as running:\n   ...\n")),(0,a.kt)("p",null,"or "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"with await Runner(...).async_run() as running:\n    ...\n")),(0,a.kt)("p",null,"If you don't use ",(0,a.kt)("inlineCode",{parentName:"p"},"Runner")," as a context manager, remember to call ",(0,a.kt)("inlineCode",{parentName:"p"},"Runner.cleanup()")," to remove any leftover temp files."),(0,a.kt)(p,{type:"class",name:"Runner",module:"metaflow",show_import:"False",heading_level:"3",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L230",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"flow_file, show_output=True, profile=None, env=None, cwd=None, **kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Metaflow's Runner API that presents a programmatic interface\\nto run flows and perform other operations either synchronously or asynchronously.\\nThe class expects a path to the flow file along with optional arguments\\nthat match top-level options on the command-line.",extended_summary:'This class works as a context manager, calling `cleanup()` to remove\\ntemporary files at exit.\\n\\nExample:\\n```python\\nwith Runner(\'slowflow.py\', pylint=False) as runner:\\n    result = runner.run(alpha=5, tags=["abc", "def"], max_workers=5)\\n    print(result.run.finished)\\n```',mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"flow_file",type:"str",desc:"Path to the flow file to run, relative to current directory.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"show_output",type:"bool, default True",desc:"Show the 'stdout' and 'stderr' to the console by default,\\nOnly applicable for synchronous 'run' and 'resume' functions.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"profile",type:"str, optional, default None",desc:"Metaflow profile to use to run this run. If not specified, the default\\nprofile is used (or the one already set using `METAFLOW_PROFILE`)",mdxType:"Parameter"}),(0,a.kt)(f,{name:"env",type:"Dict[str, str], optional, default None",desc:"Additional environment variables to set for the Run. This overrides the\\nenvironment set for this process.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"cwd",type:"str, optional, default None",desc:"The directory to run the subprocess in; if not specified, the current\\ndirectory is used.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"file_read_timeout",type:"int, default 3600",desc:"The timeout until which we try to read the runner attribute file (in seconds).",mdxType:"Parameter"}),(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` before\\nthe `run` command.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"Runner.cleanup",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L519",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Delete any temporary files created during execution.",mdxType:"Description"})),(0,a.kt)("h3",{id:"blocking-api"},"Blocking API"),(0,a.kt)("p",null,"These calls block until the command completes."),(0,a.kt)(p,{type:"method",name:"Runner.run",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L363",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Blocking execution of the run. This method will wait until\\nthe run has completed execution.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `run` command, in particular, any parameters accepted by the flow.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun containing the results of the run.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"Runner.resume",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L400",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Blocking resume execution of the run.\\nThis method will wait until the resumed run has completed execution.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python ./myflow.py` after\\nthe `resume` command.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun containing the results of the resumed run.",mdxType:"Parameter"}))),(0,a.kt)("h3",{id:"non-blocking-api"},"Non-Blocking API"),(0,a.kt)(p,{type:"method",name:"Runner.async_run",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L437",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Non-blocking execution of the run. This method will return as soon as the\\nrun has launched.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `run` command, in particular, any parameters accepted by the flow.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun representing the run that was started.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"Runner.async_resume",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L475",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Non-blocking resume execution of the run.\\nThis method will return as soon as the resume has launched.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `resume` command.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun representing the resumed run that was started.",mdxType:"Parameter"}))),(0,a.kt)("h2",{id:"nbrunner"},"NBRunner"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"NBRunner")," is a wrapper over ",(0,a.kt)("inlineCode",{parentName:"p"},"Runner")," which allows you to refer to a flow defined in a notebook cell instead of a file. For examples, see ",(0,a.kt)("a",{parentName:"p",href:"/metaflow/managing-flows/notebook-runs"},"Running flows in a notebook"),"."),(0,a.kt)(p,{type:"class",name:"NBRunner",module:"metaflow",show_import:"False",heading_level:"3",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L15",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"flow, show_output=True, profile=None, env=None, base_dir=None, **kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"A  wrapper over `Runner` for executing flows defined in a Jupyter\\nnotebook cell.",extended_summary:"Instantiate this class on the last line of a notebook cell where\\na `flow` is defined. In contrast to `Runner`, this class is not\\nmeant to be used in a context manager. Instead, use a blocking helper\\nfunction like `nbrun` (which calls `cleanup()` internally) or call\\n`cleanup()` explictly when using non-blocking APIs.\\n\\n```python\\nrun = NBRunner(FlowName).nbrun()\\n```",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"flow",type:"FlowSpec",desc:"Flow defined in the same cell",mdxType:"Parameter"}),(0,a.kt)(f,{name:"show_output",type:"bool, default True",desc:"Show the 'stdout' and 'stderr' to the console by default,\\nOnly applicable for synchronous 'run' and 'resume' functions.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"profile",type:"str, optional, default None",desc:"Metaflow profile to use to run this run. If not specified, the default\\nprofile is used (or the one already set using `METAFLOW_PROFILE`)",mdxType:"Parameter"}),(0,a.kt)(f,{name:"env",type:"Dict[str, str], optional, default None",desc:"Additional environment variables to set for the Run. This overrides the\\nenvironment set for this process.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"base_dir",type:"str, optional, default None",desc:"The directory to run the subprocess in; if not specified, the current\\nworking directory is used.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"file_read_timeout",type:"int, default 3600",desc:"The timeout until which we try to read the runner attribute file (in seconds).",mdxType:"Parameter"}),(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` before\\nthe `run` command.",mdxType:"Parameter"}))),(0,a.kt)("h3",{id:"blocking-api-1"},"Blocking API"),(0,a.kt)(p,{type:"method",name:"NBRunner.nbrun",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L113",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Blocking execution of the run. This method will wait until\\nthe run has completed execution.",extended_summary:"Note that in contrast to `run`, this method returns a\\n`metaflow.Run` object directly and calls `cleanup()` internally\\nto support a common notebook pattern of executing a flow and\\nretrieving its results immediately.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `run` command, in particular, any parameters accepted by the flow.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"Run",desc:"A `metaflow.Run` object representing the finished run.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"NBRunner.nbresume",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L138",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Blocking resuming of a run. This method will wait until\\nthe resumed run has completed execution.",extended_summary:"Note that in contrast to `resume`, this method returns a\\n`metaflow.Run` object directly and calls `cleanup()` internally\\nto support a common notebook pattern of executing a flow and\\nretrieving its results immediately.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `resume` command.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"Run",desc:"A `metaflow.Run` object representing the resumed run.",mdxType:"Parameter"}))),(0,a.kt)("h3",{id:"non-blocking-api-1"},"Non-Blocking API"),(0,a.kt)(p,{type:"method",name:"NBRunner.async_run",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L176",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Non-blocking execution of the run. This method will return as soon as the\\nrun has launched. This method is equivalent to `Runner.async_run`.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `run` command, in particular, any parameters accepted by the flow.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun representing the run that was started.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"NBRunner.async_resume",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L197",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"**kwargs",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Non-blocking execution of the run. This method will return as soon as the\\nrun has launched. This method is equivalent to `Runner.async_resume`.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"**kwargs",type:"Any",desc:"Additional arguments that you would pass to `python myflow.py` after\\nthe `run` command, in particular, any parameters accepted by the flow.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"ExecutingRun representing the run that was started.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"NBRunner.cleanup",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/nbrun.py#L217",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Delete any temporary files created during execution.",extended_summary:"Call this method after using `async_run` or `async_resume`. You don't\\nhave to call this after `nbrun` or `nbresume`.",mdxType:"Description"})),(0,a.kt)("h2",{id:"executingrun"},"ExecutingRun"),(0,a.kt)(p,{type:"class",name:"ExecutingRun",module:"metaflow",show_import:"False",heading_level:"3",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L24",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"This class contains a reference to a `metaflow.Run` object representing\\nthe currently executing or finished run, as well as metadata related\\nto the process.",extended_summary:"`ExecutingRun` is returned by methods in `Runner` and `NBRunner`. It is not\\nmeant to be instantiated directly.\\n\\nThis class works as a context manager, allowing you to use a pattern like\\n```python\\nwith Runner(...).run() as running:\\n    ...\\n```\\nNote that you should use either this object as the context manager or\\n`Runner`, not both in a nested manner.",mdxType:"Description"})),(0,a.kt)(p,{type:"property",name:"ExecutingRun.returncode",module:"metaflow.runner.metaflow_runner",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/",mdxType:"DocSection"},(0,a.kt)(y,{summary:"Gets the return code of the underlying subprocess. A non-zero\\ncode indicates a failure, `None` a currently executing run.\\n",mdxType:"Description"}),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"Optional[int]",desc:"The return code of the underlying subprocess.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"property",name:"ExecutingRun.status",module:"metaflow.runner.metaflow_runner",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/",mdxType:"DocSection"},(0,a.kt)(y,{summary:"Returns the status of the underlying subprocess that is responsible\\nfor executing the run.\\n\\nThe return value is one of the following strings:\\n- `timeout` indicates that the run timed out.\\n- `running` indicates a currently executing run.\\n- `failed` indicates a failed run.\\n- `successful` indicates a successful run.\\n",mdxType:"Description"}),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"str",desc:"The current status of the run.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"property",name:"ExecutingRun.stdout",module:"metaflow.runner.metaflow_runner",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/",mdxType:"DocSection"},(0,a.kt)(y,{summary:"Returns the current stdout of the run. If the run is finished, this will\\ncontain the entire stdout output. Otherwise, it will contain the\\nstdout up until this point.\\n",mdxType:"Description"}),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"str",desc:"The current snapshot of stdout.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"property",name:"ExecutingRun.stderr",module:"metaflow.runner.metaflow_runner",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/",mdxType:"DocSection"},(0,a.kt)(y,{summary:"Returns the current stderr of the run. If the run is finished, this will\\ncontain the entire stderr output. Otherwise, it will contain the\\nstderr up until this point.\\n",mdxType:"Description"}),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"str",desc:"The current snapshot of stderr.",mdxType:"Parameter"}))),(0,a.kt)("h3",{id:"non-blocking-api-2"},"Non-Blocking API"),(0,a.kt)(p,{type:"method",name:"ExecutingRun.wait",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L68",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"timeout",type:"Optional",default:"None",mdxType:"SigArg"}),(0,a.kt)(c,{name:"stream",type:"Optional",default:"None",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Wait for this run to finish, optionally with a timeout\\nand optionally streaming its output.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"timeout",type:"float, optional, default None",desc:"The maximum time, in seconds, to wait for the run to finish.\\nIf the timeout is reached, the run is terminated. If not specified, wait\\nforever.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"stream",type:"str, optional, default None",desc:"If specified, the specified stream is printed to stdout. `stream` can\\nbe one of `stdout` or `stderr`.",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Returns",mdxType:"ParamSection"},(0,a.kt)(f,{type:"ExecutingRun",desc:"This object, allowing you to chain calls.",mdxType:"Parameter"}))),(0,a.kt)(p,{type:"method",name:"ExecutingRun.stream_log",module:"metaflow",show_import:"False",heading_level:"4",link:"https://github.com/Netflix/metaflow/tree/master/metaflow/runner/metaflow_runner.py#L168",mdxType:"DocSection"},(0,a.kt)(d,{mdxType:"SigArgSection"},(0,a.kt)(c,{name:"self",mdxType:"SigArg"}),(0,a.kt)(c,{name:"stream",type:"str",mdxType:"SigArg"}),(0,a.kt)(c,{name:"position",type:"Optional",default:"None",mdxType:"SigArg"})),(0,a.kt)(y,{summary:"Asynchronous iterator to stream logs from the subprocess line by line.",extended_summary:"Note that this method is asynchronous and needs to be `await`ed.",mdxType:"Description"}),(0,a.kt)(h,{name:"Parameters",mdxType:"ParamSection"},(0,a.kt)(f,{name:"stream",type:"str",desc:"The stream to stream logs from. Can be one of `stdout` or `stderr`.",mdxType:"Parameter"}),(0,a.kt)(f,{name:"position",type:"int, optional, default None",desc:"The position in the log file to start streaming from. If None, it starts\\nfrom the beginning of the log file. This allows resuming streaming from\\na previously known position",mdxType:"Parameter"})),(0,a.kt)(h,{name:"Yields",mdxType:"ParamSection"},(0,a.kt)(f,{type:"Tuple[int, str]",desc:"A tuple containing the position in the log file and the line read. The\\nposition returned can be used to feed into another `stream_logs` call\\nfor example.",mdxType:"Parameter"}))))}k.isMDXComponent=!0}}]);