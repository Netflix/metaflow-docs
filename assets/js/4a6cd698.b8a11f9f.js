"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4101],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,m=u["".concat(r,".").concat(d)]||u[d]||f[d]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3381:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>f,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={},s="Creating Flows",l={unversionedId:"metaflow/basics",id:"metaflow/basics",title:"Creating Flows",description:"This document introduces the basic concepts of Metaflow. If you are eager to try out",source:"@site/docs/metaflow/basics.md",sourceDirName:"metaflow",slug:"/metaflow/basics",permalink:"/metaflow/basics",draft:!1,editUrl:"https://github.dev/Netflix/metaflow-docs/blob/master/docs/metaflow/basics.md",tags:[],version:"current",frontMatter:{},sidebar:"python",previous:{title:"Developing with Metaflow",permalink:"/metaflow/introduction"},next:{title:"Inspecting Flows and Results",permalink:"/metaflow/client"}},r={},p=[{value:"The Structure of Metaflow Code",id:"the-structure-of-metaflow-code",level:2},{value:"Linear",id:"linear",level:3},{value:"Artifacts",id:"artifacts",level:3},{value:"Branch",id:"branch",level:3},{value:"Foreach",id:"foreach",level:3},{value:"Conditionals",id:"conditionals",level:3},{value:"Recursion",id:"recursion",level:3},{value:"Nesting constructs",id:"nesting-constructs",level:3},{value:"What should be a step?",id:"what-should-be-a-step",level:2},{value:"How to define parameters for flows?",id:"how-to-define-parameters-for-flows",level:2},{value:"Advanced parameters",id:"advanced-parameters",level:3},{value:"Data flow through the graph",id:"data-flow-through-the-graph",level:2}],c={toc:p};function f(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"creating-flows"},"Creating Flows"),(0,i.kt)("p",null,"This document introduces the basic concepts of Metaflow. If you are eager to try out\nMetaflow in practice, you can start with the ",(0,i.kt)("a",{parentName:"p",href:"../getting-started/tutorials/"},"tutorial"),".\nAfter the tutorial, you can return to this document to learn more about how Metaflow\nworks."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The examples below show how to execute flows on the command line. If you want to\ndevelop flows in a notebook, take a quick look at ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/managing-flows/notebook-runs"},"how to run flows in a\nnotebook"),".")),(0,i.kt)("h2",{id:"the-structure-of-metaflow-code"},"The Structure of Metaflow Code"),(0,i.kt)("p",null,"Metaflow follows ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dataflow_programming"},"the dataflow\nparadigm")," which models a program as\na directed graph of operations. This is a natural paradigm for expressing data\nprocessing pipelines, machine learning in particular."),(0,i.kt)("p",null,"We call the graph of operations ",(0,i.kt)("strong",{parentName:"p"},"a flow"),". You define the operations, called ",(0,i.kt)("strong",{parentName:"p"},"steps"),",\nwhich are nodes of the graph and contain transitions to the next steps, which serve as\nedges."),(0,i.kt)("p",null,"Metaflow sets some constraints on the structure of the graph. For starters, every flow\nneeds a step called ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and a step called ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),". An execution of the flow, which we\ncall ",(0,i.kt)("strong",{parentName:"p"},"a run"),", starts at ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),". The run is successful if the final ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," step\nfinishes successfully."),(0,i.kt)("p",null,"What happens between ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," is up to you. You can construct the graph in\nbetween using an arbitrary combination of the following three types of transitions\nsupported by Metaflow:"),(0,i.kt)("h3",{id:"linear"},"Linear"),(0,i.kt)("p",null,"The most basic type of transition is ",(0,i.kt)("strong",{parentName:"p"},"a linear")," transition. It moves from one step to\nanother one."),(0,i.kt)("p",null,"Here is a graph with two linear transitions:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(9856).Z,width:"2322",height:"636"})),(0,i.kt)("p",null,"The corresponding Metaflow script looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\n\nclass LinearFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.my_var = 'hello world'\n        self.next(self.a)\n\n    @step\n    def a(self):\n        print('the data artifact is: %s' % self.my_var)\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print('the data artifact is still: %s' % self.my_var)\n\nif __name__ == '__main__':\n    LinearFlow()\n")),(0,i.kt)("p",null,"Save this snippet to a file, ",(0,i.kt)("inlineCode",{parentName:"p"},"linear.py"),". You can execute Metaflow flows on the command\nline like any other Python scripts. Try this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python linear.py run\n")),(0,i.kt)("p",null,"Whenever you see a flow like this in the documentation, just save it in a file and\nexecute it like above."),(0,i.kt)("h3",{id:"artifacts"},"Artifacts"),(0,i.kt)("p",null,"Besides executing the steps ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," in order, this flow creates ",(0,i.kt)("strong",{parentName:"p"},"a data\nartifact")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"my_var"),". In Metaflow, data artifacts are created simply by assigning\nvalues to instance variables like ",(0,i.kt)("inlineCode",{parentName:"p"},"my_var"),"."),(0,i.kt)("p",null,"Artifacts are a core concept of Metaflow. They have a number of uses:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"They allow you to manage the data flow through the flow without having to load and\nstore data manually.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"All artifacts are persisted so that they can be analyzed later using the ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/client"},"Client\nAPI"),", visualized with ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/visualizing-results"},"Cards"),", and\neven used across flows.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Artifacts works consistently across environments, so you can run some steps locally\nand ",(0,i.kt)("a",{parentName:"p",href:"/scaling/introduction"},"some steps in the cloud")," without having to worry about\ntransferring data explicitly.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Having access to past artifacts greatly helps ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/debugging"},"debugging"),", since\nyou can eyeball data before failures and even ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/debugging#how-to-use-the-resume-command"},"resume past\nexecutions")," after fixing bugs."))),(0,i.kt)("p",null,"Data artifacts are available in all steps after they have been created, so they behave\nas any normal instance variables. An exception to this rule are branches, as explained\nbelow."),(0,i.kt)("h3",{id:"branch"},"Branch"),(0,i.kt)("p",null,"You can express parallel steps with ",(0,i.kt)("strong",{parentName:"p"},"a branch"),". In the figure below, ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),"\ntransitions to two parallel steps, ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Any number of parallel steps are\nallowed. A benefit of a branch like this is performance: Metaflow can execute ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"b")," over multiple CPU cores or over multiple instances in the cloud."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(6051).Z,width:"2638",height:"897"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\n\nclass BranchFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.next(self.a, self.b)\n\n    @step\n    def a(self):\n        self.x = 1\n        self.next(self.join)\n\n    @step\n    def b(self):\n        self.x = 2\n        self.next(self.join)\n\n    @step\n    def join(self, inputs):\n        print('a is %s' % inputs.a.x)\n        print('b is %s' % inputs.b.x)\n        print('total is %d' % sum(input.x for input in inputs))\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == '__main__':\n    BranchFlow()\n")),(0,i.kt)("p",null,"Every branch must be joined. The join step does not need to be called ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," as above\nbut it must take an extra argument, like ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," above."),(0,i.kt)("p",null,"In the example above, the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," above is ambiguous: ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," sets it to ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"2"),". To disambiguate the branches, the join step can refer to a specific step in the\nbranch, like ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs.a.x")," above. For convenience, you can also iterate over all steps in\nthe branch using ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs"),", as done in the last print statement in the above ",(0,i.kt)("inlineCode",{parentName:"p"},"join")," step.\nFor more details, see the section about ",(0,i.kt)("a",{parentName:"p",href:"basics#data-flow-through-the-graph"},"data flow through the\ngraph"),"."),(0,i.kt)("p",null,"Note that you can nest branches arbitrarily, that is, you can branch inside a branch.\nJust remember to join all the branches that you create."),(0,i.kt)("h3",{id:"foreach"},"Foreach"),(0,i.kt)("p",null,"Static branches like above are useful when you know the branches at the development\ntime. Alternatively, you may want to branch based on data dynamically. This is the use\ncase for ",(0,i.kt)("strong",{parentName:"p"},"a foreach")," branch."),(0,i.kt)("p",null,"Foreach works similarly like the branch above but instead of creating named step\nmethods, many parallel copies of steps inside a foreach loop are executed."),(0,i.kt)("p",null,"A foreach loop can iterate over any list like ",(0,i.kt)("inlineCode",{parentName:"p"},"titles")," below."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8450).Z,width:"2666",height:"788"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\n\nclass ForeachFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.titles = ['Stranger Things',\n                       'House of Cards',\n                       'Narcos']\n        self.next(self.a, foreach='titles')\n\n    @step\n    def a(self):\n        self.title = '%s processed' % self.input\n        self.next(self.join)\n\n    @step\n    def join(self, inputs):\n        self.results = [input.title for input in inputs]\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print('\\n'.join(self.results))\n\nif __name__ == '__main__':\n    ForeachFlow()\n")),(0,i.kt)("p",null,"The foreach loop is initialized by specifying a keyword argument ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"self.next()"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach")," argument takes a string that is the name of a list stored\nin an instance variable, like ",(0,i.kt)("inlineCode",{parentName:"p"},"titles")," above."),(0,i.kt)("p",null,"Steps inside a foreach loop create separate ",(0,i.kt)("strong",{parentName:"p"},"tasks")," to process each item of the list.\nHere, Metaflow creates three parallel tasks for the step ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," to process the three items\nof the ",(0,i.kt)("inlineCode",{parentName:"p"},"titles")," list in parallel. You can access the specific item assigned to a task\nwith an instance variable called ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),"."),(0,i.kt)("p",null,"Foreach loops must be joined like static branches. Note that tasks inside a foreach loop\nare not named, so you can only iterate over them with ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs"),". If you want, you can\nassign a value to an instance variable in a foreach step which helps you to identify the\ntask."),(0,i.kt)("p",null,"You can nest foreaches and combine them with branches and linear steps arbitrarily."),(0,i.kt)("h3",{id:"conditionals"},"Conditionals"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This is a new feature in Metaflow 2.18.")),(0,i.kt)("p",null,"Conditional branches allow you to choose ",(0,i.kt)("em",{parentName:"p"},"one")," branch among multiple\noptions, based on the value of an artifact. Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach"),", you\npass a ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," keyword argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"self.next"),", pointing to an artifact\nthat determines which branch to follow. Unlike regular branches, where\nmultiple paths can run in parallel, conditional branching ensures that\nexactly one branch is executed."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8818).Z,width:"2644",height:"1219"})),(0,i.kt)("p",null,"Specify the candidate branches as a Python dictionary, similar to a\n",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statement in many languages. Dictionary keys can be any valid type\n(e.g. strings, integers, booleans), and the values must be valid ",(0,i.kt)("inlineCode",{parentName:"p"},"@step")," methods.\nThe keys may be specified\nvia ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/configuring-flows/introduction"},"a ",(0,i.kt)("inlineCode",{parentName:"a"},"Config")," file"),",\ne.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"{cfg.first_choice: self.head}"),". Note that you must specify a key for\nevery possible value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," artifact."),(0,i.kt)("p",null,"This flow flips a coin and executes a heads or tails branch accordingly: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\nimport random\n\nclass CoinFlipFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.choice = random.choice(['head', 'tails'])\n        self.next({\"head\": self.head, \"tails\": self.tails}, condition='choice')\n\n    @step\n    def head(self):\n        print('Head!')\n        self.next(self.end)\n\n    @step\n    def tails(self):\n        print('Tails!')\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print(\"This is the end\")\n\nif __name__ == '__main__':\n    CoinFlipFlow()\n")),(0,i.kt)("p",null,"Note that you don't need a join step with conditionals, since only\none branch is execution so there are no multiple sets of artifacts\nto be merged."),(0,i.kt)("h3",{id:"recursion"},"Recursion"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This is a new feature in Metaflow 2.18.")),(0,i.kt)("p",null,"While Metaflow doesn't support arbitrary loops across the flow -\nthe flows are ",(0,i.kt)("em",{parentName:"p"},"Directed")," ",(0,i.kt)("strong",{parentName:"p"},"Acyclic")," ",(0,i.kt)("em",{parentName:"p"},"Graphs")," after all - as a special\ncase, you can execute a single step multiple times recursively."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(9733).Z,width:"2511",height:"584"})),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"foreach"),", this construct causes a single step to spawn multiple tasks,\neach producing its own artifacts. Recursion is particularly useful when you want\nto ",(0,i.kt)("em",{parentName:"p"},"snapshot and persist artifacts")," before continuing processing."),(0,i.kt)("p",null,"If the flow\nfails during recursion, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"/metaflow/debugging#how-to-use-the-resume-command"},(0,i.kt)("inlineCode",{parentName:"a"},"resume")," command")," to pick up\nfrom the latest successful iteration instead of starting over. And, you are able\nto use ",(0,i.kt)("a",{parentName:"p",href:"/metaflow/client"},"the Client API")," to inspect any iteration afterwards -\nfor instance, a particular parametrization of a hyperparameter optimization loop."),(0,i.kt)("p",null,"Define recursion simply by creating a conditional where one of the branches points\nat the step itself. For instance, the example below implements the\nfollowing ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = 1\nwhile x < 5:\n   x += 1\n")),(0,i.kt)("p",null,"...as the ",(0,i.kt)("inlineCode",{parentName:"p"},"loop")," step:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\n\nclass WhileFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.next(self.loop)\n\n    @step\n    def loop(self):\n        self.x = getattr(self, 'x', 0) + 1\n        print('X is', self.x)\n        self.again = self.x < 5\n        self.next({True: self.loop, False: self.end}, condition='again')\n\n    @step\n    def end(self):\n        print(\"The final X is\", self.x)\n\nif __name__ == '__main__':\n    WhileFlow()\n")),(0,i.kt)("p",null,"You can interrupt the flow mid-execution and try ",(0,i.kt)("inlineCode",{parentName:"p"},"python while.py resume")," to observe\nhow the execution resumes from the latest successful iteration instead of starting\nagain."),(0,i.kt)("h3",{id:"nesting-constructs"},"Nesting constructs"),(0,i.kt)("p",null,"You can combine and nest the above constructs almost arbitrarily.  "),(0,i.kt)("p",null,"For example, the following flow orchestrates ",(0,i.kt)("a",{parentName:"p",href:"https://outerbounds.com/blog/agentic-metaflow"},"multiple agents working in\nparallel")," using a ",(0,i.kt)("strong",{parentName:"p"},"foreach"),".",(0,i.kt)("br",{parentName:"p"}),"\n","The agent state is persisted through ",(0,i.kt)("strong",{parentName:"p"},"recursive steps"),", and the agent can\ncontinue along a suitable path through ",(0,i.kt)("strong",{parentName:"p"},"a conditional"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(3487).Z,width:"2441",height:"1413"})),(0,i.kt)("h2",{id:"what-should-be-a-step"},"What should be a step?"),(0,i.kt)("p",null,"There is not a single right way of structuring code as a graph of steps but here are\nsome best practices that you can follow."),(0,i.kt)("p",null,"Metaflow treats steps as indivisible units of execution. That is, a step either succeeds\nor fails as a whole. After the step has finished successfully, Metaflow persists all\ninstance variables that were created in the step code, so the step does not have to be\nexecuted again even if a subsequent step fails. In other words, you can inspect data\nartifacts that were present when the step finished, but you can not inspect data that\nwere manipulated within a step."),(0,i.kt)("p",null,"This makes a step ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Application_checkpointing"},"a\ncheckpoint"),". The more granular\nyour steps are, the more control you have over inspecting results and resuming failed\nruns."),(0,i.kt)("p",null,"A downside of making steps too granular is that checkpointing adds some overhead. It\nwould not make sense to execute each line of code as a separate step. Keep your steps\nsmall but not too small. A good rule of thumb is that a single step should not take more\nthan an hour to run, preferably much less than that."),(0,i.kt)("p",null,"Another important consideration is the readability of your code. Try running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python myflow.py show\n")),(0,i.kt)("p",null,"which prints out the steps of your flow. Does the overview give you a good idea of your\ncode? If the steps are too broad, it might make sense to split them up just to make the\noverall flow more descriptive."),(0,i.kt)("h2",{id:"how-to-define-parameters-for-flows"},"How to define parameters for flows?"),(0,i.kt)("p",null,"Here is an example of a flow that defines a parameter, ",(0,i.kt)("inlineCode",{parentName:"p"},"alpha"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, Parameter, step\n\nclass ParameterFlow(FlowSpec):\n    alpha = Parameter('alpha',\n                      help='Learning rate',\n                      default=0.01)\n\n    @step\n    def start(self):\n        print('alpha is %f' % self.alpha)\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print('alpha is still %f' % self.alpha)\n\nif __name__ == '__main__':\n    ParameterFlow()\n")),(0,i.kt)("p",null,"Parameters are defined by assigning a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameter")," object to a class variable. Parameter\nvariables are automatically available in all steps, like ",(0,i.kt)("inlineCode",{parentName:"p"},"alpha")," above."),(0,i.kt)("p",null,"You can set the parameter values on the command line as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python parameter_flow.py run --alpha 0.6\n")),(0,i.kt)("p",null,"You can see available parameters with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python parameter_flow.py run --help\n")),(0,i.kt)("p",null,"Parameters are typed based on the type of their default value. If there is no meaningful\ndefault for a parameter, you can define it as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"num_components = Parameter('num_components',\n                           help='Number of components',\n                           required=True,\n                           type=int)\n")),(0,i.kt)("p",null,"Now the flow can not be run without setting ",(0,i.kt)("inlineCode",{parentName:"p"},"--num_components")," to an integer value."),(0,i.kt)("p",null,"See the API reference for ",(0,i.kt)("a",{parentName:"p",href:"/api/flowspec#parameters"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"Parameter")," class")," for more\ninformation."),(0,i.kt)("h3",{id:"advanced-parameters"},"Advanced parameters"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For even more versatile ways to configure flows, take a look at\n",(0,i.kt)("a",{parentName:"p",href:"/metaflow/configuring-flows/introduction"},"Configuring Flows"),".")),(0,i.kt)("p",null,"In the example above, ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameters")," took simple scalar values, such as integers or\nfloating point values. To support more complex values for ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameter"),", Metaflow allows\nyou to specify the value as JSON. This feature comes in handy if your ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameter")," is a\nlist of values, a mapping, or a more complex data structure."),(0,i.kt)("p",null,"This example allows the user to define a GDP by country mapping as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parameter"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, Parameter, step, JSONType\n\nclass JSONParameterFlow(FlowSpec):\n    gdp = Parameter('gdp',\n                    help='Country-GDP Mapping',\n                    type=JSONType,\n                    default='{\"US\": 1939}')\n\n    country = Parameter('country',\n                        help='Choose a country',\n                        default='US')\n\n    @step\n    def start(self):\n        print('The GDP of %s is $%dB' % (self.country, self.gdp[self.country]))\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == '__main__':\n    JSONParameterFlow()\n")),(0,i.kt)("p",null,"Execute the code as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"python parameter_flow.py run --gdp '{\"US\": 1}'\n")),(0,i.kt)("h2",{id:"data-flow-through-the-graph"},"Data flow through the graph"),(0,i.kt)("p",null,"As previously mentioned, for ",(0,i.kt)("a",{parentName:"p",href:"basics#linear"},"linear")," steps, data artifacts are\npropagated and any linear step can access data artifacts created by previous steps using\ninstance variables. In this case, Metaflow can easily determine the value of each\nartifact by simply taking the value of that artifact at the end of the previous step."),(0,i.kt)("p",null,"In a join step, however, the value of artifacts can potentially be set to different\nvalues on the incoming branches; the value of the artifact is said to be ambiguous."),(0,i.kt)("p",null,"To make it easier to implement a join step after foreach or branch, Metaflow provides a\nutility function, ",(0,i.kt)("inlineCode",{parentName:"p"},"merge_artifacts"),", to aid in propagating unambiguous values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from metaflow import FlowSpec, step\n\nclass MergeArtifactsFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.pass_down = 'a'\n        self.next(self.a, self.b)\n\n    @step\n    def a(self):\n        self.common = 5\n        self.x = 1\n        self.y = 3\n        self.from_a = 6\n        self.next(self.join)\n\n    @step\n    def b(self):\n        self.common = 5\n        self.x = 2\n        self.y = 4\n        self.next(self.join)\n\n    @step\n    def join(self, inputs):\n        self.x = inputs.a.x\n        self.merge_artifacts(inputs, exclude=['y'])\n        print('x is %s' % self.x)\n        print('pass_down is %s' % self.pass_down)\n        print('common is %d' % self.common)\n        print('from_a is %d' % self.from_a)\n        self.next(self.c)\n\n    @step\n    def c(self):\n        self.next(self.d, self.e)\n\n    @step\n    def d(self):\n        self.conflicting = 7\n        self.next(self.join2)\n\n    @step\n    def e(self):\n        self.conflicting = 8\n        self.next(self.join2)\n\n    @step\n    def join2(self, inputs):\n        self.merge_artifacts(inputs, include=['pass_down', 'common'])\n        print('Only pass_down and common exist here')\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == '__main__':\n    MergeArtifactsFlow()\n")),(0,i.kt)("p",null,"In the example above, the ",(0,i.kt)("inlineCode",{parentName:"p"},"merge_artifacts")," function behaves as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"join"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"pass_down")," is propagated because it is unmodified in both ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b"),"."),(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"join"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"common")," is also propagated because it is set to the same value in both\nbranches. Remember that it is the value of the artifact that matters when determining\nwhether an artifact is ambiguous; Metaflow uses ",(0,i.kt)("a",{parentName:"li",href:"/internals/technical-overview#datastore"},"content based\ndeduplication")," to store artifacts and can\ntherefore determine if the value of two artifacts is the same."),(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"join"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," is handled by the code explicitly ",(0,i.kt)("em",{parentName:"li"},"prior")," to the call to\n",(0,i.kt)("inlineCode",{parentName:"li"},"merge_artifacts")," which causes ",(0,i.kt)("inlineCode",{parentName:"li"},"merge_artifacts")," to ignore ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," when propagating\nartifacts. This pattern allows you to manually resolve any ambiguity in artifacts you\nwould like to see propagated."),(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"join"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"y")," is not propagated because it is listed in the ",(0,i.kt)("inlineCode",{parentName:"li"},"exclude")," list. This\npattern allows you to prevent the propagation of artifacts that are no longer\nrelevant. Remember that the default behavior of ",(0,i.kt)("inlineCode",{parentName:"li"},"merge_artifacts")," is to propagate all\nincoming artifacts."),(0,i.kt)("li",{parentName:"ul"},"in ",(0,i.kt)("inlineCode",{parentName:"li"},"join"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"from_a")," is propagated because it is only set in one branch and therefore\nis unambiguous. ",(0,i.kt)("inlineCode",{parentName:"li"},"merge_artifacts"),"will propagate all values even if they are present on\nonly one incoming branch."),(0,i.kt)("li",{parentName:"ul"},"In ",(0,i.kt)("inlineCode",{parentName:"li"},"join2"),", the ",(0,i.kt)("inlineCode",{parentName:"li"},"include")," keyword is used and allows you to explicitly specify the\nartifacts to consider when merging. This is useful when the list of artifacts to\nexclude is larger than the one to include. You cannot use both an ",(0,i.kt)("inlineCode",{parentName:"li"},"include")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"exclude")," list in the same ",(0,i.kt)("inlineCode",{parentName:"li"},"merge_artifacts")," call. Note also that if an artifact is\nspecified in ",(0,i.kt)("inlineCode",{parentName:"li"},"include"),", an error will be thrown if it either doesn't exist in the\ncurrent step or doesn't exist on one of the inputs ","(",'in other words, it is\n"missing"',")",". The ",(0,i.kt)("inlineCode",{parentName:"li"},"include")," parameter is only available in version 2.2.1 or later.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"merge_artifacts")," function will raise an exception if an artifact that it should\nmerge has an ambiguous value. Remember that ",(0,i.kt)("inlineCode",{parentName:"p"},"merge_artifacts")," will attempt to merge all\nincoming artifacts except if they are already present in the step or have been\nexplicitly excluded in the ",(0,i.kt)("inlineCode",{parentName:"p"},"exclude")," list."))}f.isMDXComponent=!0},6051:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-branch-3090f3b037c1ced969022124c06fcd8e.png"},8818:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-conditional-bd969669ed1a2454e4b10f7992fe63f1.png"},8450:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-foreach-91ff2db37bb4465d36568736fe67a71d.png"},9856:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-linear-993e81bf5e5f28a45fcf128d5a990087.png"},3487:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-nested-4a6b08abad0cb97ea5097a769d015bb0.png"},9733:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dag-recursion-dd7243176dfd5715bcac6a64895a6d6f.png"}}]);