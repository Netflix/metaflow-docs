"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1718],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5850:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={},i="Custom Decorators",s={unversionedId:"metaflow/composing-flows/custom-decorators",id:"metaflow/composing-flows/custom-decorators",title:"Custom Decorators",description:"You can find all decorator examples in this repository.",source:"@site/docs/metaflow/composing-flows/custom-decorators.md",sourceDirName:"metaflow/composing-flows",slug:"/metaflow/composing-flows/custom-decorators",permalink:"/metaflow/composing-flows/custom-decorators",draft:!1,editUrl:"https://github.dev/Netflix/metaflow-docs/blob/master/docs/metaflow/composing-flows/custom-decorators.md",tags:[],version:"current",frontMatter:{},sidebar:"python",previous:{title:"Composing Flows with Custom Decorators",permalink:"/metaflow/composing-flows/introduction"},next:{title:"Advanced Custom Decorators",permalink:"/metaflow/composing-flows/advanced-custom-decorators"}},l={},p=[{value:"Defining a custom decorator",id:"defining-a-custom-decorator",level:2},{value:"Using a custom decorator",id:"using-a-custom-decorator",level:2},{value:"Using custom decorators when executing tasks remotely",id:"using-custom-decorators-when-executing-tasks-remotely",level:3},{value:"Configuring decorators and managing state",id:"configuring-decorators-and-managing-state",level:2},{value:"Exposing an API to the user code",id:"exposing-an-api-to-the-user-code",level:2}],c={toc:p};function m(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"custom-decorators"},"Custom Decorators"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"You can find ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/outerbounds/custom-decorator-examples"},"all decorator examples in this repository"),".")),(0,o.kt)("p",null,"Custom decorators let you:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Run code ",(0,o.kt)("strong",{parentName:"p"},"before")," the user-defined step,")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Run code ",(0,o.kt)("strong",{parentName:"p"},"after")," the user-defined step,")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Run code ",(0,o.kt)("strong",{parentName:"p"},"on failure")," of the user-defined step,")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Replace")," the user-defined step with custom logic,"))),(0,o.kt)("p",null,"Notably, in any of the above cases, you can read, write, or delete ",(0,o.kt)("strong",{parentName:"p"},"artifacts")," to\nmaintain state within and across steps, as well as to process inputs and outputs from your decorator.\nThis page describes the basic usage of custom decorators covering the before and after cases. The next\npage, ",(0,o.kt)("a",{parentName:"p",href:"/metaflow/composing-flows/advanced-custom-decorators"},"Advanced Custom Decorators"),", covers the\nlast two patterns."),(0,o.kt)("h2",{id:"defining-a-custom-decorator"},"Defining a custom decorator"),(0,o.kt)("p",null,"A custom step decorator is a Python generator function, annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"@user_step_decorator"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import time\nfrom metaflow import user_step_decorator, current\n\n@user_step_decorator\ndef my_profile(step_name, flow, inputs=None, attributes=None):\n    start = time.time()\n    yield\n    duration = 1000 * (time.time() - start)\n    print(f"\u23f0 Task [{current.pathspec}] completed in {duration:.1f}ms")\n')),(0,o.kt)("p",null,"The function is passed four arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"step_name")," - the step that is being decorated. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"flow")," - a ",(0,o.kt)("inlineCode",{parentName:"li"},"FlowSpec")," object, corresponding to ",(0,o.kt)("inlineCode",{parentName:"li"},"self")," in steps - used to access artifacts."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"inputs")," - a list of ",(0,o.kt)("inlineCode",{parentName:"li"},"inputs")," if the decorated function is ",(0,o.kt)("a",{parentName:"li",href:"/metaflow/basics#branch"},"a join step"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"attributes")," - a dictionary of keyword arguments passed to the decorator.")),(0,o.kt)("p",null,"Any code before ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," is executed before the user-defined step code. Code after it is executed\nafter the user's code has executed successfully. As an example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"@my_profile")," decorator above\nmeasures and prints the execution time of the user code in milliseconds. Save it to a file, ",(0,o.kt)("inlineCode",{parentName:"p"},"myprofile.py"),"."),(0,o.kt)("h2",{id:"using-a-custom-decorator"},"Using a custom decorator"),(0,o.kt)("p",null,"You can use the decorator in any Metaflow flow simply by importing it"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"from myprofile import my_profile\n")),(0,o.kt)("p",null,"and by annotating steps with ",(0,o.kt)("inlineCode",{parentName:"p"},"@my_profile"),". Alternatively, you can attach the decorator automatically\nto all steps by executing a flow with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"python myflow.py run --with myprofile.my_profile\n")),(0,o.kt)("p",null,"You can test the above with this flow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import time\nfrom metaflow import FlowSpec, step\n\nfrom myprofiler import my_profile\n\nclass WaiterFlow(FlowSpec):\n\n    @step\n    def start(self):\n        self.waiters = list(range(5))\n        self.next(self.wait, foreach='waiters')\n\n    @my_profile\n    @step\n    def wait(self):\n        self.duration = self.input / 10\n        print(f\"\ud83d\udca4 Sleeping for {self.duration}s\")\n        time.sleep(self.duration)\n        self.next(self.join)\n\n    @step\n    def join(self, inputs):\n        self.total = sum(inp.duration for inp in inputs)\n        print(f\"Slept {self.total}s in total\")\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == '__main__':\n    WaiterFlow()\n")),(0,o.kt)("p",null,"Save it as ",(0,o.kt)("inlineCode",{parentName:"p"},"waiterflow.py")," and run it as usual:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"python waiterflow.py run\n")),(0,o.kt)("p",null,"You can also test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"python waiterflow.py run --with myprofiler.my_profile\n")),(0,o.kt)("h3",{id:"using-custom-decorators-when-executing-tasks-remotely"},"Using custom decorators when executing tasks remotely"),(0,o.kt)("p",null,"Custom decorators don't require special treatment when ",(0,o.kt)("a",{parentName:"p",href:"/scaling/remote-tasks/introduction"},"executing tasks in\nthe cloud")," or when ",(0,o.kt)("a",{parentName:"p",href:"/production/introduction"},"deploying flows to production")," -\nthey will get ",(0,o.kt)("a",{parentName:"p",href:"/scaling/dependencies#unpacking-a-metaflow-project"},"packaged automatically by Metaflow"),". You don't\neven need to ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," the decorators if you add them with ",(0,o.kt)("inlineCode",{parentName:"p"},"--with"),". Try it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"python waiterflow.py run --with myprofiler.my_profile --with kubernetes\n")),(0,o.kt)("p",null,"or equally ",(0,o.kt)("inlineCode",{parentName:"p"},"--with batch"),". Notably, the decorators don't have to exist in the same ",(0,o.kt)("a",{parentName:"p",href:"/scaling/dependencies/project-structure"},"directory\nhierarchy as your flow code"),", nor you have to include them with ",(0,o.kt)("inlineCode",{parentName:"p"},"@pypi"),"."),(0,o.kt)("p",null,"If your custom decorator is part of a Python package with multiple modules, Metaflow will automatically package the entire package. This allows you to implement advanced decorators as well-structured Python packages, which can be distributed internally via your internal package repository or published to PyPI. If your decorator requires third-party dependencies, you can include them using a bundled ",(0,o.kt)("inlineCode",{parentName:"p"},"@pypi")," decorator, as shown in ",(0,o.kt)("a",{parentName:"p",href:"#"},"this example"),"."),(0,o.kt)("h2",{id:"configuring-decorators-and-managing-state"},"Configuring decorators and managing state"),(0,o.kt)("p",null,"Your decorators may want to manage state across steps, or you may want to produce results that can be accessed\nafter a run has completed. You can do this via artifacts. "),(0,o.kt)("p",null,"In the example below, save it to ",(0,o.kt)("inlineCode",{parentName:"p"},"statsprofiler.py"),", we aggregate timings from all tasks in an artifact,\n",(0,o.kt)("inlineCode",{parentName:"p"},"timings"),". Note that we use ",(0,o.kt)("inlineCode",{parentName:"p"},"hasattr")," to see if the artifact exists already, and we check the presence of\n",(0,o.kt)("inlineCode",{parentName:"p"},"inputs")," to merge timings in a join step:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import time\nfrom metaflow import user_step_decorator\nfrom collections import defaultdict\n\n@user_step_decorator\ndef stats_profile(step_name, flow, inputs=None, attributes=None):\n    start = time.time()\n    yield\n    duration = int(1000 * (time.time() - start))\n\n    if not hasattr(flow, "timings"):\n        flow.timings = defaultdict(list)\n    if inputs:\n        for inp in inputs:\n            for step, timings in inp.timings.items():\n                flow.timings[step].extend(timings)\n    flow.timings[step_name].append(duration)\n    if step_name == "end" and not attributes.get("silent"):\n        print_results(flow.timings)\n\ndef print_results(all_timings):\n    print("\ud83d\udcca Step timings")\n    print(f"{\'Step\':<20}{\'P10 (ms)\':<15}{\'Median (ms)\':<15}{\'P90 (ms)\':<15}")\n    for step, timings in all_timings.items():\n        timings.sort()\n        n = len(timings)\n        p10 = timings[int(n * 0.1)]\n        median = timings[n // 2]\n        p90 = timings[int(n * 0.9)]\n        print(f"{step:<20}{p10:<15}{median:<15}{p90:<15}")\n')),(0,o.kt)("p",null,"You can also configure the decorator behavior through ",(0,o.kt)("inlineCode",{parentName:"p"},"attributes"),". Here, you can set"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"@stats_profile(silent=True)\n")),(0,o.kt)("p",null,"to suppress outputting of results. Or, on the command line:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"python waiterflow.py run --with statsprofiler.stats_profile:silent=1\n")),(0,o.kt)("p",null,"You can then use ",(0,o.kt)("a",{parentName:"p",href:"/metaflow/client"},"the Client API")," as usual to\naccess the results in the ",(0,o.kt)("inlineCode",{parentName:"p"},"timings")," artifact."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1073).Z,width:"1385",height:"904"})),(0,o.kt)("h2",{id:"exposing-an-api-to-the-user-code"},"Exposing an API to the user code"),(0,o.kt)("p",null,"A custom decorator can expose an API to user code via a temporary artifact. This allows you to maintain state using arbitrarily complex Python objects - such as instances of custom classes - that may not be easily serializable or retrievable as stable artifacts through the Client API."),(0,o.kt)("p",null,"This example, ",(0,o.kt)("inlineCode",{parentName:"p"},"traceprofiler.py"),", exposes ",(0,o.kt)("a",{parentName:"p",href:"https://realpython.com/python-with-statement/"},"a Python context manager"),"\nthrough ",(0,o.kt)("inlineCode",{parentName:"p"},"self.trace")," which the user code can use to collect timings of arbitrary sections of code. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import time\nfrom metaflow import user_step_decorator\nfrom collections import defaultdict\n\n@user_step_decorator\ndef trace_profile(step_name, flow, inputs=None, attributes=None):\n    flow.trace = TraceCollector\n    yield\n    del flow.trace\n    flow.timings = TraceCollector.timings\n    for name, timings in TraceCollector.timings.items():\n        print(f"Trace: {name} - Total: {int(timings)}ms")\n\nclass TraceCollector(object):\n\n    timings = defaultdict(int)\n\n    def __init__(self, name):\n        self.name = name\n\n    def __enter__(self):\n        self.start = time.time()\n\n    def __exit__(self, type, value, traceback):\n        self.timings[self.name] += 1000 * (time.time() - self.start)\n')),(0,o.kt)("p",null,"It wouldn't make sense to store the context manager class, ",(0,o.kt)("inlineCode",{parentName:"p"},"TraceCollector"),", as an artifact so we delete\nit (",(0,o.kt)("inlineCode",{parentName:"p"},"del flow.trace"),") after the user code has finished and only store a dictionary of results as an artifact.\nThe following flow demonstrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"with self.trace")," in action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import time\nfrom metaflow import FlowSpec, step\n\nfrom traceprofiler import trace_profile\n\nclass TracingFlow(FlowSpec):\n\n    @trace_profile\n    @step\n    def start(self):\n        for i in range(10):\n            with self.trace('database access'):\n                time.sleep(0.1)\n        with self.trace('process data'):\n            time.sleep(0.5)\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == '__main__':\n    TracingFlow()\n")))}m.isMDXComponent=!0},1073:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/statsprofiler-598fe6bb4494df4841856e6017ce2685.png"}}]);