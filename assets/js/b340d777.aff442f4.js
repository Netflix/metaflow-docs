"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9685],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>m});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},f=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,f=l(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,d=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return t?r.createElement(d,a(a({ref:n},f),{},{components:t})):r.createElement(d,a({ref:n},f))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var p=2;p<o;p++)a[p]=t[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8397:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(7462),i=(t(7294),t(3905));const o={},a="Custom Config Parsers",l={unversionedId:"metaflow/configuring-flows/custom-parsers",id:"metaflow/configuring-flows/custom-parsers",title:"Custom Config Parsers",description:"The primary purpose of the parser argument in Config is to enable support for different configuration formats, as",source:"@site/docs/metaflow/configuring-flows/custom-parsers.md",sourceDirName:"metaflow/configuring-flows",slug:"/metaflow/configuring-flows/custom-parsers",permalink:"/metaflow/configuring-flows/custom-parsers",draft:!1,editUrl:"https://github.dev/Netflix/metaflow-docs/blob/master/docs/metaflow/configuring-flows/custom-parsers.md",tags:[],version:"current",frontMatter:{},sidebar:"python",previous:{title:"Parsing Configs",permalink:"/metaflow/configuring-flows/parsing-configs"},next:{title:"Config-Driven Experimentation",permalink:"/metaflow/configuring-flows/config-driven-experimentation"}},s={},p=[{value:"Generating configs programmatically",id:"generating-configs-programmatically",level:2},{value:"Including default configs in flows",id:"including-default-configs-in-flows",level:2}],f={toc:p};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"custom-config-parsers"},"Custom Config Parsers"),(0,i.kt)("p",null,"The primary purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"parser")," argument in ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," is to enable support for different configuration formats, as\n",(0,i.kt)("a",{parentName:"p",href:"parsing-configs"},"explained in the previous section"),". As parsers are arbitrary Python functions, one can leverage them\nmore creatively as well, including generating configurations on the fly."),(0,i.kt)("p",null,"For instance, a custom parser could contact an external service to fetch a suitable config. Or, it\ncould examine data and other context to determine a suitable configuration dynamically."),(0,i.kt)("h2",{id:"generating-configs-programmatically"},"Generating configs programmatically"),(0,i.kt)("p",null,"To illustrate config generation, consider this example that annotates each deployment with information about\nthe current ",(0,i.kt)("inlineCode",{parentName:"p"},"git")," branch through a custom parser function, ",(0,i.kt)("inlineCode",{parentName:"p"},"git_info"),". It generates a config on the fly by\ncalling the ",(0,i.kt)("inlineCode",{parentName:"p"},"git")," command."),(0,i.kt)("p",null,"This example should be run in an existing Git repository. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/outerbounds/config-examples/blob/main/git-info/"},"Check out the\nexample")," from its repository for testing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from subprocess import check_output\nfrom metaflow import FlowSpec, step, Config, current, card\nfrom metaflow.cards import Markdown, Table\n\ndef git_info(args):\n    info = {\n        "commit": ["git", "rev-parse", "HEAD"],\n        "branch": ["git", "rev-parse", "--abbrev-ref", "HEAD"],\n        "message": ["git", "log", "-1", "--pretty=%B"],\n    }\n    cfg = {}\n    for key, cmd in info.items():\n        cfg[key] = check_output(cmd, text=True).strip()\n    return cfg\n\nclass GitInfoFlow(FlowSpec):\n    git_info = Config("git_info", default_value="", parser=git_info)\n\n    def output_git_info(self):\n        table = [\n            [Markdown(f"**{k.capitalize()}**"), v] for k, v in self.git_info.items()\n        ]\n        current.card["git"].append(Markdown(f"# Deployment info"))\n        current.card["git"].append(Table(table))\n\n    @card(type="blank", id="git")\n    @step\n    def start(self):\n        print("Git info", self.git_info)\n        self.output_git_info()\n        self.next(self.end)\n\n    @step\n    def end(self):\n        pass\n\nif __name__ == "__main__":\n    GitInfoFlow()\n')),(0,i.kt)("p",null,"As the config is generated on the fly, we don't need any config files to be present. We set\n",(0,i.kt)("inlineCode",{parentName:"p"},"Config(default_value='')")," to inform ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," that we can proceed without a config file."),(0,i.kt)("p",null,"You can run the flow as usual:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python git_info.py run\n")),(0,i.kt)("p",null,"and view the resulting card:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python git_config.py card view start\n")),(0,i.kt)("h2",{id:"including-default-configs-in-flows"},"Including default configs in flows"),(0,i.kt)("p",null,"The example above is practically useful, as it ensures that every deployment and local run includes\nlineage information about the originating Git branch. Thanks to ",(0,i.kt)("inlineCode",{parentName:"p"},"Config"),", this information is stored\nin an artifact, making it easy to inspect later."),(0,i.kt)("p",null,"We may want to ensure that all flows include this information. We could include a ",(0,i.kt)("inlineCode",{parentName:"p"},"Config")," line with\na ",(0,i.kt)("inlineCode",{parentName:"p"},"git_info")," parser in every flow, but it adds unnecessary boilerplate which developers shouldn't have\nto worry about."),(0,i.kt)("p",null,"Instead, we can create ",(0,i.kt)("em",{parentName:"p"},"a ",(0,i.kt)("inlineCode",{parentName:"em"},"FlowSpec")," template")," or superclass which takes care of this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from subprocess import check_output\n\nfrom metaflow import FlowSpec, Config, current\nfrom metaflow.cards import Markdown, Table\n\ndef git_info(args):\n    info = {\n        "commit": ["git", "rev-parse", "HEAD"],\n        "branch": ["git", "rev-parse", "--abbrev-ref", "HEAD"],\n        "message": ["git", "log", "-1", "--pretty=%B"],\n    }\n    cfg = {}\n    for key, cmd in info.items():\n        cfg[key] = check_output(cmd, text=True).strip()\n    return cfg\n\nclass TrackedFlowSpec(FlowSpec):\n    git_info = Config("git_info", default_value="", parser=git_info)\n\n    def output_git_info(self):\n        print("deployment info", self.git_info)\n        if hasattr(current, "card"):\n            table = [\n                [Markdown(f"**{k.capitalize()}**"), v] for k, v in self.git_info.items()\n            ]\n            current.card.append(Markdown(f"# Deployment info"))\n            current.card.append(Table(table))\n')),(0,i.kt)("p",null,"We can distribute this module, ",(0,i.kt)("inlineCode",{parentName:"p"},"tracked_flow.py"),", containing ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackedFlowSpec")," as a shared base class\nfor flows to inherit from, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"MyTrackedFlow"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from metaflow import step, Config\nfrom tracked_flow import TrackedFlowSpec\n\nclass MyTrackedFlow(TrackedFlowSpec):\n    config = Config("config", default="myconfig.json")\n\n    @step\n    def start(self):\n        self.output_git_info()\n        self.next(self.end)\n\n    @step\n    def end(self):\n        print("config", self.config)\n\nif __name__ == "__main__":\n    MyTrackedFlow()\n')),(0,i.kt)("p",null,"An important detail here is that ",(0,i.kt)("inlineCode",{parentName:"p"},"MyTrackedFlow")," derives from ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackedFlowSpec"),", instead of the usual\nMetaflow ",(0,i.kt)("inlineCode",{parentName:"p"},"FlowSpec"),". Since ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackedFlowSpec")," includes ",(0,i.kt)("inlineCode",{parentName:"p"},"git_info"),", all derived flows will have it too, in addition\nto any ",(0,i.kt)("inlineCode",{parentName:"p"},"Config"),"s they define by themselves such as ",(0,i.kt)("inlineCode",{parentName:"p"},"config")," above."),(0,i.kt)("p",null,"When you run ",(0,i.kt)("inlineCode",{parentName:"p"},"MyTrackedFlow"),", it will record its ",(0,i.kt)("inlineCode",{parentName:"p"},"git")," lineage in ",(0,i.kt)("inlineCode",{parentName:"p"},"git_info")," automatically without boilerplate.\nOptionally, if you run the flow ",(0,i.kt)("inlineCode",{parentName:"p"},"--with card"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"output_git_info")," will populate a card with the lineage information."))}c.isMDXComponent=!0}}]);